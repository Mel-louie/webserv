[1mdiff --git a/.vscode/launch.json b/.vscode/launch.json[m
[1mindex 796207d..ccde18e 100644[m
[1m--- a/.vscode/launch.json[m
[1m+++ b/.vscode/launch.json[m
[36m@@ -9,7 +9,7 @@[m
             "type": "cppdbg",[m
             "request": "launch",[m
             "program": "${workspaceFolder}/webserv",[m
[31m-            "args": ["4212"],[m
[32m+[m[32m            "args": ["4201"],[m
             "stopAtEntry": false,[m
             "cwd": "${fileDirname}",[m
             "environment": [],[m
[1mdiff --git a/config_and_cgi_classes/CGI.cpp b/config_and_cgi_classes/CGI.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..b6447d2[m
[1m--- /dev/null[m
[1m+++ b/config_and_cgi_classes/CGI.cpp[m
[36m@@ -0,0 +1,185 @@[m
[32m+[m[32m#include "CGI.hpp"[m
[32m+[m
[32m+[m[32m// print the env and args for testing[m
[32m+[m[32mvoid display_cgi_env(char **env, char **args)[m
[32m+[m[32m{[m
[32m+[m[32m    std::cout << "---- CGI ENV VARIABLES ----" << std::endl;[m
[32m+[m[32m    for (int i = 0 ; env[i] ; i++)[m
[32m+[m[32m        std::cout << env[i] << std::endl;[m
[32m+[m[32m    std::cout << "---- CGI ARGS EXECUTE ----" << std::endl;[m
[32m+[m[32m    for (int j = 0 ; args[j] ; j++)[m
[32m+[m[32m        std::cout << args[j] << std::endl;[m
[32m+[m[32m    std::cout << "---------------------------" << std::endl;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mCGI::CGI() {}[m
[32m+[m
[32m+[m[32mCGI::~CGI() {}[m
[32m+[m
[32m+[m[32mvoid CGI::set_binary(str_t path)[m
[32m+[m[32m{[m
[32m+[m[32m    _binary = path;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid CGI::set_input(str_t content)[m
[32m+[m[32m{[m
[32m+[m[32m    _input = content;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid free_str_tab(char **str_tab)[m
[32m+[m[32m{[m[41m	[m
[32m+[m	[32mint i = -1;[m
[32m+[m	[32mwhile (str_tab[++i] != 0)[m
[32m+[m		[32mfree(str_tab[i]);[m
[32m+[m	[32mfree(str_tab);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid free_cgi(char **args, char **env)[m
[32m+[m[32m{[m
[32m+[m[32m    free_str_tab(args);[m
[32m+[m[32m    free_str_tab(env);[m
[32m+[m[32m    args = NULL;[m
[32m+[m[32m    env = NULL;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid CGI::exec_cgi(str_t target, Request req)[m
[32m+[m[32m{[m
[32m+[m[32m    char **args = NULL;[m
[32m+[m[32m    char **env = NULL;[m
[32m+[m[41m   [m
[32m+[m[32m    args = (char**)malloc(sizeof(char*) * 3);[m
[32m+[m[32m    args[0] = strdup(_binary.c_str());[m
[32m+[m[32m    args[1] = strdup(target.c_str());[m
[32m+[m[32m    args[2] = 0;[m
[32m+[m
[32m+[m[32m// add request to build a complete env[m
[32m+[m[32m    env = build_cgi_env(req);[m
[32m+[m	[32m// display_cgi_env(env, args);[m
[32m+[m
[32m+[m[32m    pid_t pid;[m
[32m+[m	[32m// int fd_out[2];[m
[32m+[m	[32m// int fd_in[2];[m
[32m+[m	[32mint save_stdin;[m
[32m+[m	[32mint save_stdout;[m
[32m+[m	[32mchar **env;[m
[32m+[m	[32mstr_t body;[m
[32m+[m
[32m+[m[32m    if ((pid = fork()) == -1)[m
[32m+[m[32m        throw str_t("error: fork failed on CGI: PID = -1");[m
[32m+[m[32m    // else if (pid == 0)[m
[32m+[m[32m    // {[m
[32m+[m	[32m// 	// STDOUT become a copy of fd_out[1], and, in case of POST, STDIN become a copy of fd_in[0][m
[32m+[m[32m    //     dup2(fd_out[1], STDOUT_FILENO);[m
[32m+[m	[32m// 	close(fd_out[0]);[m
[32m+[m	[32m// 	close(fd_out[1]);[m
[32m+[m
[32m+[m	[32m// 	dup2(fd_in[0], STDIN_FILENO);[m
[32m+[m	[32m// 	close(fd_in[0]);[m
[32m+[m	[32m// 	close(fd_in[1]);[m
[32m+[m
[32m+[m	[32m// 	if (execve(_binary.c_str(), args, env) < 0)[m
[32m+[m	[32m// 		exit(-1);				// bail d\erreur Ã  renvoyer[m[41m [m
[32m+[m[32m    // }[m
[32m+[m	[32m// else[m
[32m+[m	[32m// {[m
[32m+[m	[32m// 	close(fd_out[1]);[m
[32m+[m
[32m+[m	[32m// 	if (req.type() == R_POST)[m
[32m+[m	[32m// 	{[m
[32m+[m	[32m// 		if (write(fd_in[1], [req.body], req.body size) < 0)[m
[32m+[m	[32m// 			throw str_t("error 500: write failed in exec_cgi method");[m
[32m+[m	[32m// 	}[m
[32m+[m	[32m// 	else[m
[32m+[m	[32m// 	{[m
[32m+[m	[32m// 		if (write(fd_in[1], ))[m
[32m+[m	[32m// 	}[m
[32m+[m	[32m// }[m
[32m+[m
[32m+[m	[32m// save stdin and out to turn them back to normal after[m
[32m+[m	[32msave_stdin = dup(STDIN_FILENO);[m
[32m+[m	[32msave_stdout = dup(STDOUT_FILENO);[m
[32m+[m
[32m+[m[41m	[m
[32m+[m
[32m+[m[32m    free_cgi(args, env);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m* --- variables related to the server ---[m
[32m+[m[32m* GATEWAY_INTERFACE       : CGI Version[m
[32m+[m[32m* SERVER_SOFTWARE         : Serveur[m
[32m+[m[32m* SERVER_NAME             : host name, alias DNS or IP address[m
[32m+[m[32m* --- variables related to the request ---[m
[32m+[m[32m* SERVER_PROTOCOL         : Protocole[m
[32m+[m[32m* SERVER_PORT             : Port[m
[32m+[m[32m* REQUEST_METHOD          : Method, generally GET or POST[m
[32m+[m[32m* PATH_INFO               : Supp script's path give by the client. EX: ifthe server hosts "/cgi-bin/myscript.cgi" and the client asks for the url "http://server.org/cgi-bin/myscript.cgi/mysearch", PATH_INFO will contain "mysearch"[m
[32m+[m[32m* PATH_TRANSLATED         : getcwd + root (sans le .) + uri[m
[32m+[m[32m* SCRIPT_NAME             : virtual path to the executed script. EX: Â« /cgi-bin/script.cgi Â»[m
[32m+[m[32m* QUERY_STRING            : The URL-encoded information that is sent with GET method request, everything that follows the "?" in the URL. Else, empty[m
[32m+[m[32m* CONTENT_LENGTH          : If method=POST, contained the CGIstring's lenght. Else 0[m
[32m+[m[32m* REMOTE_ADDR             : client IP[m
[32m+[m[32m* CONTENT_TYPE            : content type attached to the request. EX: a form send with POST[m
[32m+[m[32m* REQUEST_URI             : requested URI[m
[32m+[m[32m* REDIRECT_STATUS         : to make php-cgi work[m
[32m+[m[32m* --- variables from the client ---[m
[32m+[m[32m* All variables that are sent by the client are also passed to the CGI script, after the[m
[32m+[m[32m* server has added the "HTTP_" prefix[m
[32m+[m[32m* Ref: https://fr.wikipedia.org/wiki/Variables_d%27environnement_CGI[m
[32m+[m[32m* Ref: https://web.developpez.com/cgic.htm[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32mchar **CGI::build_cgi_env(Request req)[m
[32m+[m[32m{[m
[32m+[m[32m    char **env;[m
[32m+[m[32m    strMap envMap;[m
[32m+[m	[32munsigned int type;[m
[32m+[m
[32m+[m[32m    /* Get and set CGI informations */[m
[32m+[m[32m    envMap["GATEWAY_INTERFACE"] = "CGI/1.1";[m
[32m+[m[32m    envMap["SERVER_SOFTWARE"] = "webserv";[m
[32m+[m[32m    envMap["SERVER_NAME"] = "127.0.0.1";[m
[32m+[m[32m    envMap["SERVER_PROTOCOL"] = SERVER_VERSION;[m
[32m+[m[32m    envMap["SERVER_PORT"] = ""; // depuis le port recup dans le request??? need to convert char* to string, using constructor of std::string?[m
[32m+[m
[32m+[m	[32mtype = req.type();[m
[32m+[m	[32mstr_t method_type = std::to_string(type);[m
[32m+[m	[32menvMap["REQUEST_METHOD"] = method_type; // from request[m
[32m+[m[41m    [m
[32m+[m	[32menvMap["PATH_INFO"] = ""; // uri from request[m
[32m+[m[32m    envMap["PATH_TRANSLATED"] = ""; // need request location and uri[m
[32m+[m[32m    envMap["SCRIPT_NAME"] = ""; // need from request[m
[32m+[m[32m    envMap["QUERY_STRING"] = ""; // "[m
[32m+[m[32m    envMap["CONTENT_LENGTH"] = ""; // body size[m
[32m+[m[32m    envMap["REMOTE_ADDR"] = ""; // client ip[m
[32m+[m[32m    envMap["CONTENT_TYPE"] = ""; // content type from req[m
[32m+[m[32m    envMap["REQUEST_URI"] = ""; // uri from req[m
[32m+[m[32m    //envMap["REDIRECT_STATUS"] = "200"; //[m
[32m+[m
[32m+[m[32m    /* Request headers pass to CGI */[m
[32m+[m[32m    envMap["HTTP_EXAMPLE"] = "EXAMPLE"; // needs HTTP prefix[m
[32m+[m[32m    // to code[m
[32m+[m
[32m+[m[32m    int i = -1;[m
[32m+[m[32m    env = (char**)malloc(sizeof(char*) * (envMap.size() + 1));[m
[32m+[m
[32m+[m[32m    for (strMap::iterator it = envMap.begin() ; it != envMap.end() ; it++)[m
[32m+[m[32m        env[++i] = (char*)strdup((it->first + "=" + it->second).c_str());[m
[32m+[m
[32m+[m[32m    env[++i] = 0;[m
[32m+[m[32m    envMap.clear();[m
[32m+[m[32m    return (env);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint main ()[m
[32m+[m[32m{[m
[32m+[m[32m    CGI cgi;[m
[32m+[m	[32mRequest req("uwu", 2);[m
[32m+[m
[32m+[m[32m    // set binary (path) for the cgi[m
[32m+[m[32m    cgi.set_binary("BINARY NAME");[m
[32m+[m[32m    // execute cgi[m
[32m+[m[32m    cgi.exec_cgi("CGI ARG", req);[m
[32m+[m
[32m+[m[32m    return 0;[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/config_and_cgi_classes/CGI.hpp b/config_and_cgi_classes/CGI.hpp[m
[1mnew file mode 100644[m
[1mindex 0000000..fb003c2[m
[1m--- /dev/null[m
[1m+++ b/config_and_cgi_classes/CGI.hpp[m
[36m@@ -0,0 +1,36 @@[m
[32m+[m[32m// when method == (POST || GET)[m
[32m+[m[32m// set binary (path)[m
[32m+[m[32m// execute[m
[32m+[m[32m//      built env (meta-variables https://datatracker.ietf.org/doc/html/rfc3875#section-4.1) passed to execve[m
[32m+[m[32m//      build execve 2nd arguments (array of string with path to binary (_binary) and arguments (target))[m
[32m+[m[32m//      Pipe / Fork / Excve / Dup2 to write output to file and make CGI read the POST Body[m
[32m+[m[32m//      in the parent, write BODY in STDIN of child with tube[m[41m [m
[32m+[m[32m//      then, parse the CGI output, knowing that its output format will always be (whatever the CGI is) : headers ... \r\n\r\n ... body[m
[32m+[m[32m// get output[m
[32m+[m
[32m+[m[32m#ifndef CGI_HPP[m
[32m+[m[32m# define CGI_HPP[m
[32m+[m
[32m+[m[32m# include "../include/common.hpp"[m
[32m+[m[32m#include "../include/Request.hpp"[m
[32m+[m
[32m+[m[32mclass CGI[m
[32m+[m[32m{[m
[32m+[m[32m    public:[m
[32m+[m[32m        CGI();[m
[32m+[m[32m        ~CGI();[m
[32m+[m
[32m+[m[32m        void set_binary(str_t path);[m
[32m+[m[32m        void set_input(str_t content); //  in a CGI-BIN environment, you read the data from STDIN[m
[32m+[m
[32m+[m[32m        void exec_cgi(str_t target, Request req);[m
[32m+[m
[32m+[m[32m    private:[m
[32m+[m[32m        str_t _binary;[m
[32m+[m[32m        str_t _input;[m
[32m+[m		[32mstr_t _body;[m
[32m+[m[41m        [m
[32m+[m[32m        char **build_cgi_env(Request req);[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m#endif[m
\ No newline at end of file[m
[1mdiff --git a/config_and_cgi_classes/CGI_explaned.md b/config_and_cgi_classes/CGI_explaned.md[m
[1mnew file mode 100644[m
[1mindex 0000000..e3e7240[m
[1m--- /dev/null[m
[1m+++ b/config_and_cgi_classes/CGI_explaned.md[m
[36m@@ -0,0 +1,27 @@[m
[32m+[m[32mcgi : Common Gateway Interface (littÃ©ralement "interface de passerelle commune"), est une interface utilisÃ©e par les serveurs HTTP.[m
[32m+[m
[32m+[m[32mAu lieu d'envoyer le contenu d'un fichier (fichier HTML, image, ...), le serveur HTTP exÃ©cute un programme, puis retourne le contenu gÃ©nÃ©rÃ©. On passe a la CGI les informations via execve(path, args) puis on rÃ©cupÃ¨re l'output du CGI. On forme la rÃ©ponse et on la send().[m
[32m+[m
[32m+[m[32mLa propriÃ©tÃ© method indique la maniÃ¨re dont on transmet les donnÃ©es entrÃ©es par l'utilisateur au programme.[m[41m [m
[32m+[m
[32m+[m[32mIl existe deux mÃ©thodes de transmission des donnÃ©es diffÃ©rentes : method=POST et method=GET. Suivant la mÃ©thode choisie, il faudra Ã©crire le programme CGI d'une maniÃ¨re adaptÃ©e.[m
[32m+[m
[32m+[m[32mLa mÃ©thode GET transmet les donnÃ©es de maniÃ¨re visible en les ajoutant a la suite de l'URL conduisant au programme cgi, sous la forme suivante : "www.example.fr/cgi-bin/cgi.exe?name1=value1&ame2=value2&name3=value3...." . Cette mÃ©thode est peu pratique et Ã©galement peu sÃ©curisante dans la mesure ou toutes les donnÃ©es que vous entrez (mÃªme votre mot de passe par exemple) sont rendues visibles Ã  tous dans l'URL. Il est donc dÃ©conseillÃ© de l'utiliser.[m
[32m+[m
[32m+[m[32mLa mÃ©thode POST est plus satisfaisante dans la mesure oÃ¹ elle transmet les donnÃ©es de maniÃ¨re invisible au programme. C'est celle qu'il est recommandÃ© d'utiliser.[m
[32m+[m
[32m+[m[32mEn plus des donnÃ©es entrÃ©es par l'utilisateur, le programme peut rÃ©cupÃ©rer un certain nombre d'informations sur le contexte de travail. On peut en effet obtenir les valeurs des variables d'environnement suivantes :[m
[32m+[m
[32m+[m[32mVariable d'environnement 	Information fournie[m
[32m+[m[32mSERVER_SOFTWARE 	Nom du logiciel serveur Web[m
[32m+[m[32mSERVER_NAME 	Nom DNS de la machine hÃ©bergeant le serveur Web[m
[32m+[m[32mGATEWAY_INTERFACE 	Version du protocole CGI utilisÃ©e par le serveur[m
[32m+[m[32mSERVER_PROTOCOL 	Version du protocole HTTP utilisÃ©e par le serveur[m
[32m+[m[32mSERVER_PORT 	Port utilisÃ© par le serveur Web[m
[32m+[m[32mREQUEST_METHOD 	MÃ©thode (GET ou POST) selon laquelle le formulaire a Ã©tÃ© soumis[m
[32m+[m[32mPATH_TRANSLATED 	Chemin complet menant au programme CGI lancÃ©[m
[32m+[m[32mSCRIPT_NAME 	Nom du programme CGI lancÃ©[m
[32m+[m[32mQUERY_STRING 	Si method=GET, contient la chaÃ®ne CGI, sinon vide[m
[32m+[m[32mCONTENT_LENGTH 	Si method=POST, contient la longeur de la chaÃ®ne CGI, sinon 0[m
[32m+[m[32mREMOTE_HOST 	Nom DNS de la machine distante qui a soumis le formulaire[m
[32m+[m[32mREMOTE_ADDR 	Adresse IP de cette machine distante[m
\ No newline at end of file[m
[1mdiff --git a/config_louie/Config.cpp b/config_and_cgi_classes/Config.cpp[m
[1msimilarity index 97%[m
[1mrename from config_louie/Config.cpp[m
[1mrename to config_and_cgi_classes/Config.cpp[m
[1mindex 0e60947..87f6829 100644[m
[1m--- a/config_louie/Config.cpp[m
[1m+++ b/config_and_cgi_classes/Config.cpp[m
[36m@@ -232,12 +232,6 @@[m [mvoid Config::set_location(str_t line)[m
     }[m
 }[m
 [m
[31m-// not sur if mymetypes are mandatory[m
[31m-// void Config::set_mimetypes(strMap mimetypes)[m
[31m-// {[m
[31m-//     this->_mimetypes = mimetypes;[m
[31m-// }[m
[31m-[m
 /*[m
 * Getters[m
 */[m
[36m@@ -260,9 +254,6 @@[m [mstr_t Config::autoindex() const { return (this->_autoindex); }[m
 [m
 std::vector<Location> Config::location() const { return (this->_location); }[m
 [m
[31m-// not sur if mymetypes are mandatory[m
[31m-// strMap Config::mimetypes() const { return (this->_mimetypes); }[m
[31m-[m
 /*[m
 * Member functions[m
 */[m
[36m@@ -374,7 +365,7 @@[m [mstd::ostream& operator<<(std::ostream& os, Config const& src)[m
     strMap error_pages = src.error_page();[m
     if (error_pages.empty() == false)[m
         for (strMap::const_iterator it = error_pages.begin() ; it != error_pages.end() ; ++it)[m
[31m-            os << "\t-" << it->first << " " << it->second << std::endl;[m
[32m+[m[32m            os << "\t- " << it->first << " " << it->second << std::endl;[m
 [m
     os << "client_max_body_size: " << src.client_max() << std::endl;[m
     [m
[1mdiff --git a/config_louie/Config.hpp b/config_and_cgi_classes/Config.hpp[m
[1msimilarity index 84%[m
[1mrename from config_louie/Config.hpp[m
[1mrename to config_and_cgi_classes/Config.hpp[m
[1mindex c9f15a8..6e89e1b 100644[m
[1m--- a/config_louie/Config.hpp[m
[1m+++ b/config_and_cgi_classes/Config.hpp[m
[36m@@ -23,15 +23,10 @@[m [mclass Config[m
         std::list<str_t>        index() const;[m
         str_t                   autoindex() const;[m
         std::vector<Location>   location() const;[m
[31m-        // strMap                  mimetypes() const;[m
[31m-[m
[31m-        str_t               search_config(str_t config, str_t key);[m
[31m-        std::vector<size_t> search_location(str_t config);[m
 [m
     private:[m
         str_t                   _host;[m
         std::vector<int>        _port;[m
[31m-        // char                    *_port;[m
         std::vector<str_t>      _server_name;[m
         strMap                  _error_page;[m
         size_t                  _client_max_body_size;[m
[36m@@ -39,10 +34,10 @@[m [mclass Config[m
         std::list<str_t>        _index;[m
         str_t                   _autoindex;[m
         std::vector<Location>   _location;[m
[31m-[m
[31m-        // not sur if mymetypes are mandatory[m
[31m-        // strMap                  _mimetypes;[m
        [m
[32m+[m[32m        str_t               search_config(str_t config, str_t key);[m
[32m+[m[32m        std::vector<size_t> search_location(str_t config);[m
[32m+[m
         void set_host_port(str_t line);[m
         void set_server_name(str_t line);[m
         void set_error_page(str_t line);[m
[36m@@ -51,9 +46,6 @@[m [mclass Config[m
         void set_index(str_t line);[m
         void set_autoindex(str_t line);[m
         void set_location(str_t line);[m
[31m-[m
[31m-        // not sur if mymetypes are mandatory[m
[31m-        // void set_mimetypes(strMap mimetypes);[m
         [m
         Config();[m
 };[m
[1mdiff --git a/config_louie/Location.cpp b/config_and_cgi_classes/Location.cpp[m
[1msimilarity index 60%[m
[1mrename from config_louie/Location.cpp[m
[1mrename to config_and_cgi_classes/Location.cpp[m
[1mindex 8646442..1b65a4a 100644[m
[1m--- a/config_louie/Location.cpp[m
[1m+++ b/config_and_cgi_classes/Location.cpp[m
[36m@@ -1,20 +1,17 @@[m
 #include "Location.hpp"[m
 [m
 /*[m
[31m-*   set_fastcgi_pass(): defines the address of a CGI server[m
[31m-*           a domain name or an IP address, and a port, ex: fastcgi_pass  127.0.0.1:9000;[m
[31m-*   set_fastcgi_param(): array directive that can be used to set parameters to values[m
[31m-*           most often, this is used in conjunction with variables to set FastCGI parameters[m
[31m-*           to values specific to the request[m
[32m+[m[32m*[m
 */[m
 [m
 Location::Location(str_t block)[m
 {[m
[31m-    this->_path = block.substr(0, block.find(" "));[m
[32m+[m[32m    this->_root = block.substr(0, block.find(" "));[m
     set_autoindex(search_config(block, "autoindex"));[m
     set_index(search_config(block, "index"));[m
[31m-    set_fastcgi_pass(search_config(block, "fastcgi_pass"));[m
[31m-    set_fastcgi_param(search_config(block, "fastcgi_param"));[m
[32m+[m[32m    set_cgi_path(search_config(block, "cgi_path"));[m
[32m+[m[32m    set_cgi_extension(search_config(block, "cgi_extension"));[m
[32m+[m[32m    // set_fastcgi_param(search_config(block, "fastcgi_param"));[m
 }[m
 [m
 Location::Location(const Location &ref)[m
[36m@@ -24,6 +21,10 @@[m [mLocation::Location(const Location &ref)[m
 [m
 Location::~Location() {}[m
 [m
[32m+[m[32m/*[m
[32m+[m[32m* Setters[m
[32m+[m[32m*/[m
[32m+[m
 void Location::set_autoindex(str_t line)[m
 {[m
     str_t tmp;[m
[36m@@ -40,10 +41,6 @@[m [mvoid Location::set_autoindex(str_t line)[m
         throw str_t("error: bad arguement for autoindex");[m
 }[m
 [m
[31m-/*[m
[31m-* Setters[m
[31m-*/[m
[31m-[m
 void Location::set_index(str_t line)[m
 {[m
     size_t space;[m
[36m@@ -61,33 +58,40 @@[m [mvoid Location::set_index(str_t line)[m
     }[m
 }[m
 [m
[31m-void Location::set_fastcgi_pass(str_t line)[m
[32m+[m[32mvoid Location::set_cgi_path(str_t line)[m
 {[m
[31m-    if (line == "")[m
[31m-        this->_fastcgi_pass = "";[m
[32m+[m[32m   if (line == "")[m
[32m+[m[32m       this->_cgi_path = "";[m
     else[m
[31m-        this->_fastcgi_pass = line.substr(line.find(" ") + 1);[m
[32m+[m[32m        this->_cgi_path = line.substr(line.find(" ") + 1);[m
 }[m
 [m
[31m-[m
[31m-void Location::set_fastcgi_param(str_t line)[m
[32m+[m[32mvoid Location::set_cgi_extension(str_t line)[m
 {[m
[31m-    size_t space;[m
[31m-    size_t space2;[m
[31m-    size_t end;[m
[32m+[m[32m   if (line == "")[m
[32m+[m[32m       this->_cgi_extension = "";[m
[32m+[m[32m    else[m
[32m+[m[32m        this->_cgi_extension = line.substr(line.find(" ") + 1);[m
[32m+[m[32m}[m
 [m
[31m-    if (line == "")[m
[31m-        return ;[m
[31m-    space = line.find(" ");[m
[31m-    space2 = space + 1;[m
[32m+[m[32m// void Location::set_fastcgi_param(str_t line)[m
[32m+[m[32m// {[m
[32m+[m[32m//     size_t space;[m
[32m+[m[32m//     size_t space2;[m
[32m+[m[32m//     size_t end;[m
[32m+[m
[32m+[m[32m//     if (line == "")[m
[32m+[m[32m//         return ;[m
[32m+[m[32m//     space = line.find(" ");[m
[32m+[m[32m//     space2 = space + 1;[m
     [m
[31m-    while (line[space2] != ' ') { space2++; };[m
[32m+[m[32m//     while (line[space2] != ' ') { space2++; };[m
 [m
[31m-    end = space2 + 1;[m
[31m-    while (line[end] != str_t::npos) { end++; }[m
[32m+[m[32m//     end = space2 + 1;[m
[32m+[m[32m//     while (line[end] != str_t::npos) { end++; }[m
 [m
[31m-    this->_fastcgi_param.insert(std::pair<str_t, str_t>(line.substr(space + 1, line.find(' ', space + 1)), line.substr(space2 + 1, end)));[m
[31m-}[m
[32m+[m[32m//     this->_fastcgi_param.insert(std::pair<str_t, str_t>(line.substr(space + 1, line.find(' ', space + 1)), line.substr(space2 + 1, end)));[m
[32m+[m[32m// }[m
 [m
 /*[m
 * Getters[m
[36m@@ -97,11 +101,13 @@[m [mstr_t Location::autoindex() const { return (this->_autoindex); }[m
 [m
 std::list<str_t> Location::index() const { return (this->_index); }[m
 [m
[31m-str_t Location::fastcgi_pass() const { return (this->_fastcgi_pass); }[m
[32m+[m[32mstr_t Location::cgi_path() const { return (this->_cgi_path); }[m
 [m
[31m-strMap Location::fastcgi_param() const { return (this->_fastcgi_param); }[m
[32m+[m[32mstr_t Location::cgi_extension() const { return (this->_cgi_extension); }[m
 [m
[31m-str_t Location::path() const { return (this->_path); }[m
[32m+[m[32mstr_t Location::root() const { return (this->_root); }[m
[32m+[m
[32m+[m[32m// strMap Location::fastcgi_param() const { return (this->_fastcgi_param); }[m
 [m
 /*[m
 * Member functions[m
[36m@@ -148,7 +154,7 @@[m [mstr_t Location::search_config(str_t config, str_t key)[m
 std::ostream& operator<<(std::ostream& os, Location const& src)[m
 {[m
     os << "{" << std::endl;[m
[31m-    os << "\tpath: " << src.path() << std::endl;[m
[32m+[m[32m    os << "\troot: " << src.root() << std::endl;[m
     [m
     os << "\tautoindex: " << src.autoindex() << std::endl;[m
     os << "\tindex:" << std::endl;[m
[36m@@ -157,14 +163,16 @@[m [mstd::ostream& operator<<(std::ostream& os, Location const& src)[m
     for (std::list<std::string>::iterator it = index.begin() ; it != index.end() ; ++it)[m
         os << "\t\t- " << *it << std::endl;[m
     [m
[31m-    os << "\tfastcgi_path: " << src.fastcgi_pass() <<std::endl;[m
[32m+[m[32m    os << "\tcgi_path: " << src.cgi_path() <<std::endl;[m
[32m+[m[41m    [m
[32m+[m[32m   os << "\tcgi_extension: " << src.cgi_extension() <<std::endl;[m
 [m
[31m-    os << "\tfastcgi_param: " << std::endl;[m
[31m-    strMap param = src.fastcgi_param();[m
[32m+[m[32m    // os << "\tfastcgi_param: " << std::endl;[m
[32m+[m[32m    // strMap param = src.fastcgi_param();[m
 [m
[31m-    for (strMap::iterator it = param.begin() ; it != param.end() ; ++it)[m
[31m-		os << it->first << " => " << it->second << std::endl;[m
[31m-	os << std::endl;	[m
[32m+[m[32m    // for (strMap::iterator it = param.begin() ; it != param.end() ; ++it)[m
[32m+[m	[32m// 	os << it->first << " => " << it->second << std::endl;[m
[32m+[m	[32m// os << std::endl;[m[41m	[m
 [m
     os << "}" << std::endl;[m
     return (os);[m
[1mdiff --git a/config_louie/Location.hpp b/config_and_cgi_classes/Location.hpp[m
[1msimilarity index 60%[m
[1mrename from config_louie/Location.hpp[m
[1mrename to config_and_cgi_classes/Location.hpp[m
[1mindex 6870fc2..8ac690d 100644[m
[1m--- a/config_louie/Location.hpp[m
[1m+++ b/config_and_cgi_classes/Location.hpp[m
[36m@@ -13,23 +13,28 @@[m [mclass Location[m
 [m
 		str_t 				autoindex() const;[m
 		std::list<str_t>	index() const;[m
[31m-		str_t				fastcgi_pass() const;[m
[31m-		strMap				fastcgi_param() const;[m
[31m-		str_t				path() const;[m
[32m+[m		[32mstr_t				root() const;[m
[32m+[m		[32mstr_t				cgi_path() const;[m
[32m+[m		[32mstr_t				cgi_extension() const ;[m
[32m+[m		[32m// strMap				fastcgi_param() const;[m
 [m
 		str_t search_config(str_t config, str_t key);[m
 [m
 	private:[m
 		str_t				_autoindex;[m
 		std::list<str_t>	_index;[m
[31m-		str_t				_fastcgi_pass;[m
[31m-		strMap				_fastcgi_param;[m
[31m-		str_t				_path;[m
[32m+[m		[32mstr_t				_root;[m
[32m+[m		[32mstr_t				_cgi_path;[m
[32m+[m		[32mstr_t				_cgi_extension;[m
[32m+[m
[32m+[m		[32m// strMap				_fastcgi_param;[m
 		[m
 		void set_autoindex(str_t line);[m
 		void set_index(str_t line);[m
[31m-		void set_fastcgi_pass(str_t line);[m
[31m-		void set_fastcgi_param(str_t line);[m
[32m+[m		[32mvoid set_cgi_path(str_t line);[m
[32m+[m		[32mvoid set_cgi_extension(str_t line);[m
[32m+[m
[32m+[m		[32m// void set_fastcgi_param(str_t line);[m
 [m
 		Location();[m
 };[m
[1mdiff --git a/config_and_cgi_classes/a.out b/config_and_cgi_classes/a.out[m
[1mnew file mode 100755[m
[1mindex 0000000..60f9c38[m
Binary files /dev/null and b/config_and_cgi_classes/a.out differ
[1mdiff --git a/config_louie/empty.conf b/config_and_cgi_classes/empty.conf[m
[1msimilarity index 100%[m
[1mrename from config_louie/empty.conf[m
[1mrename to config_and_cgi_classes/empty.conf[m
[1mdiff --git a/config_louie/miniConf.conf b/config_and_cgi_classes/miniConf.conf[m
[1msimilarity index 82%[m
[1mrename from config_louie/miniConf.conf[m
[1mrename to config_and_cgi_classes/miniConf.conf[m
[1mindex e25d99b..ea78311 100644[m
[1m--- a/config_louie/miniConf.conf[m
[1m+++ b/config_and_cgi_classes/miniConf.conf[m
[36m@@ -11,8 +11,6 @@[m [mserver[m
 	index   index.html;[m
 [m
 [m
[31m-[m
[31m-[m
     root  /;[m
 [m
     autoindex off;[m
[36m@@ -20,6 +18,9 @@[m [mserver[m
     location / {[m
 		index index.html;[m
 		autoindex off;[m
[32m+[m		[32mcgi_extension .php;[m
[32m+[m		[32mcgi_path /usr/bin/cgi-bin;[m
[32m+[m
     }[m
 [m
 }[m
\ No newline at end of file[m
[1mdiff --git a/config_louie/main.cpp b/config_and_cgi_classes/parse_config.cpp[m
[1msimilarity index 94%[m
[1mrename from config_louie/main.cpp[m
[1mrename to config_and_cgi_classes/parse_config.cpp[m
[1mindex b63b2d9..6437e7c 100644[m
[1m--- a/config_louie/main.cpp[m
[1m+++ b/config_and_cgi_classes/parse_config.cpp[m
[36m@@ -5,20 +5,21 @@[m
 #include <string>[m
 #include "Config.hpp"[m
 [m
[31m-// template<typename T>[m
[31m-// void    printVec(std::vector<T> &v)[m
[31m-// {[m
[31m-// 	size_t  last = v.size() - 1;[m
[31m-[m
[31m-// 	std::cout << "{" ;[m
[31m-// 	for (size_t i = 0 ; i < v.size() ; ++i)[m
[31m-// 	{[m
[31m-// 		std::cout << v[i];[m
[31m-// 		if (i != last)[m
[31m-// 			std::cout << ", ";[m
[31m-// 	}[m
[31m-// 	std::cout << "}" << std::endl;[m
[31m-// };[m
[32m+[m[32m// print vectors to debug[m
[32m+[m[32mtemplate<typename T>[m
[32m+[m[32mvoid    printVec(std::vector<T> &v)[m
[32m+[m[32m{[m
[32m+[m	[32msize_t  last = v.size() - 1;[m
[32m+[m
[32m+[m	[32mstd::cout << "{" ;[m
[32m+[m	[32mfor (size_t i = 0 ; i < v.size() ; ++i)[m
[32m+[m	[32m{[m
[32m+[m		[32mstd::cout << v[i];[m
[32m+[m		[32mif (i != last)[m
[32m+[m			[32mstd::cout << ", ";[m
[32m+[m	[32m}[m
[32m+[m	[32mstd::cout << "}" << std::endl;[m
[32m+[m[32m};[m
 [m
 std::vector<size_t> get_server(std::string config)[m
 {[m
[1mdiff --git a/config_and_cgi_classes/readME.md b/config_and_cgi_classes/readME.md[m
[1mnew file mode 100644[m
[1mindex 0000000..13d159e[m
[1m--- /dev/null[m
[1m+++ b/config_and_cgi_classes/readME.md[m
[36m@@ -0,0 +1,36 @@[m
[32m+[m[32mmots clef ( in server{ } ) Ã  implÃ©menter dans le fichier de config :[m
[32m+[m
[32m+[m[32m> listen	        		(port d'Ã©coute)[m
[32m+[m[32m> host				        (interface rÃ©seau)[m
[32m+[m[32m> server_name	        	(virtual host)[m
[32m+[m[32m> root		        		(server global root)[m
[32m+[m[32m> error_page				(custom error pages)[m
[32m+[m[32m> client_max_body_size		(la taille maximale pour le corps des requÃªtes envoyÃ©es par le client)[m
[32m+[m
[32m+[m[32min block location { } :[m
[32m+[m[32m> index				(le fichier d'index Ã  rechercher)[m
[32m+[m[32m> autoindex			(activation ou non de l'autoindex)[m
[32m+[m[32m> cgi_extension		(l'extension de fichier signalant la nÃ©cessitÃ© de transfÃ©rer au CGI)[m
[32m+[m[32m> cgi_bin			(le chemin de l'exÃ©cutable CGI, Ubuntu standard path: /usr/bin/cgi-bin)[m
[32m+[m[32m> root				(redÃ©finit la racine de cette route indÃ©pendamment de la racine globale)[m
[32m+[m
[32m+[m[32m? :[m
[32m+[m[32m[> methods					(les mÃ©thodes HTTP acceptÃ©es pour cette route)][m
[32m+[m[32m[> auth_basic				(activation ou non de l'authentification)][m
[32m+[m[32m[> auth_basic_user_file		(le fichier contenant les credentials si l'authentification est activÃ©e, format : username:password, 1 par ligne)][m
[32m+[m[32m[> language					(le langage prÃ©fÃ©rÃ© pour cette route) ][m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mliens stylÃ©s :[m
[32m+[m
[32m+[m[32m- http://nginx.org/en/docs/beginners_guide.html[m
[32m+[m
[32m+[m[32m- http://nginx.org/en/docs/http/request_processing.html[m
[32m+[m
[32m+[m[32m- http://nginx.org/en/docs/http/server_names.html[m
[32m+[m
[32m+[m[32m- https://www.digitalocean.com/community/tutorials/understanding-the-nginx-configuration-file-structure-and-configuration-contexts[m
[32m+[m
[32m+[m[32m- https://www.keycdn.com/support/nginx-directory-index#:~:text=By%20default%2C%20Nginx%20tries%20to,is%20if%20it%20has%20permissions[m
\ No newline at end of file[m
[1mdiff --git a/config_louie/toDo b/config_and_cgi_classes/toDo[m
[1msimilarity index 56%[m
[1mrename from config_louie/toDo[m
[1mrename to config_and_cgi_classes/toDo[m
[1mindex 2047122..5b17565 100644[m
[1m--- a/config_louie/toDo[m
[1m+++ b/config_and_cgi_classes/toDo[m
[36m@@ -1,8 +1,26 @@[m
[32m+[m[32m<--- CONFIG --->[m
[32m+[m
 âï¸ transformer la .conf recuperee pour en faire une string a passer a la class Config (on a besoin de quelque chose du genre : server { listen 8080; server_name localhost server_1; error_page 404 html/404; client_max_body_size 2000000000; index index.html; root /; autoindex off; location / { index index.html; autoindex on; } })[m
 [m
 âï¸ creer un object Config non vide[m
 [m
 ð checker le nombre de {}[m
 [m
[31m-ð mimetypes ?[m
[32m+[m[32mð mimetypes?[m
[32m+[m
[32m+[m[32m<--- CGI --->[m
[32m+[m
[32m+[m[32mð recuperer les meta-variables depuis la request pour set l env[m
[32m+[m
[32m+[m[32mð recuperer le body dans request[m
[32m+[m
[32m+[m[32mð recuperer les variables send par le client[m
[32m+[m
[32m+[m[32mð need un get_method dans resquest pour savoir s'il s'agit de POST ou GET pour le CGI[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mð[m[41m [m
[32m+[m[32mð[m[41m [m
[41m+[m
 [m
[1mdiff --git a/config_louie/readME.md b/config_louie/readME.md[m
[1mdeleted file mode 100644[m
[1mindex e7e1cdd..0000000[m
[1m--- a/config_louie/readME.md[m
[1m+++ /dev/null[m
[36m@@ -1,34 +0,0 @@[m
[31m-mots clef ( in server{ } ) Ã  implÃ©menter dans le fichier de config :[m
[31m-[m
[31m-- listen[m
[31m-[m
[31m-- server_name[m
[31m-[m
[31m-- error_page[m
[31m-[m
[31m-- client_max_body_size[m
[31m-[m
[31m-- root[m
[31m-[m
[31m-- index[m
[31m-[m
[31m-- autoindex[m
[31m-[m
[31m-- location :[m
[31m-    - autoindex[m
[31m-    - index[m
[31m-    - fastcgi_param[m
[31m-    - fastcgi_pass[m
[31m-[m
[31m-[m
[31m-liens stylÃ©s :[m
[31m-[m
[31m-- http://nginx.org/en/docs/beginners_guide.html[m
[31m-[m
[31m-- http://nginx.org/en/docs/http/request_processing.html[m
[31m-[m
[31m-- http://nginx.org/en/docs/http/server_names.html[m
[31m-[m
[31m-- https://www.digitalocean.com/community/tutorials/understanding-the-nginx-configuration-file-structure-and-configuration-contexts[m
[31m-[m
[31m-- https://www.keycdn.com/support/nginx-directory-index#:~:text=By%20default%2C%20Nginx%20tries%20to,is%20if%20it%20has%20permissions[m
\ No newline at end of file[m
[1mdiff --git a/include/Client.hpp b/include/Client.hpp[m
[1mnew file mode 100644[m
[1mindex 0000000..076f399[m
[1m--- /dev/null[m
[1m+++ b/include/Client.hpp[m
[36m@@ -0,0 +1,37 @@[m
[32m+[m[32m#ifndef CLIENT_HPP[m
[32m+[m[32m# define CLIENT_HPP[m
[32m+[m
[32m+[m[32m#include "common.hpp"[m
[32m+[m[32m#include "Request.hpp"[m
[32m+[m[32m#include "Response.hpp"[m
[32m+[m
[32m+[m
[32m+[m[32mclass Client[m
[32m+[m[32m{[m
[32m+[m	[32mpublic:[m
[32m+[m		[32mClient(int fd);[m
[32m+[m		[32m//Client(const Client &ref);[m
[32m+[m		[32mClient	&operator=(const Client &ref);[m
[32m+[m		[32m~Client(void);[m
[32m+[m		[32mvoid	add_request();[m
[32m+[m		[32mint		add_data();[m
[32m+[m		[32mvoid	respond();[m
[32m+[m		[32mint		fd();[m
[32m+[m		[32mtime_t	expire();[m
[32m+[m		[32mchar	*buff();[m
[32m+[m		[32mvoid	touch();[m
[32m+[m
[32m+[m	[32mprivate:[m
[32m+[m		[32mClient(void);[m
[32m+[m		[32mint						_fd;[m
[32m+[m		[32mstd::vector<Request>	_req;[m
[32m+[m		[32mstr_t					_input;[m
[32m+[m		[32mchar            		_buff[MAXREAD+1];[m
[32m+[m		[32munsigned int			_headers_len;[m
[32m+[m		[32munsigned int			_content_len;[m
[32m+[m		[32mtime_t					_expire;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mtypedef std::vector<Client>		client_v;[m
[32m+[m
[32m+[m[32m#endif[m
\ No newline at end of file[m
[1mdiff --git a/include/EvMa.hpp b/include/EvMa.hpp[m
[1mindex 0729a85..bb95b80 100644[m
[1m--- a/include/EvMa.hpp[m
[1m+++ b/include/EvMa.hpp[m
[36m@@ -2,7 +2,7 @@[m
 # define EVMA_HPP[m
 [m
 #include "common.hpp"[m
[31m-[m
[32m+[m[32m#include "Client.hpp"[m
 class EvMa[m
 {[m
 	public:[m
[36m@@ -20,9 +20,10 @@[m [mclass EvMa[m
 		int		_max_event;[m
 		int		_event_nb;[m
 [m
[31m-		expiryList	_timeouts;[m
[31m-		event_t		_event;	//rename it _tmp_event[m
[31m-		event_t		*_events;[m
[32m+[m		[32m//expiryList			_timeouts;[m
[32m+[m		[32mevent_t				_event;	//rename it _tmp_event[m
[32m+[m		[32mevent_t				*_events;[m
[32m+[m		[32mstd::vector<Client>	_clients;[m
 [m
 		void	init_socket( );[m
 		int		unlock_socket(int fd);[m
[36m@@ -30,9 +31,12 @@[m [mclass EvMa[m
 		void	add_to_interest(int fd);[m
 		void	incoming_connections();[m
 		int		read_data(int i);[m
[32m+[m		[32mint		write_data(int i);[m
 		int		timeout();[m
[32m+[m		[32mClient	&find_by_fd(int fd);[m
 		void	update_expiry(int fd);[m
[31m-		expiryIt	disconnect_socket(expiryIt expired);[m
[32m+[m		[32mbool	is_connected(int fd);[m
[32m+[m		[32mclient_v::iterator	disconnect_socket(client_v::iterator expired);[m
 };[m
 [m
 #endif[m
\ No newline at end of file[m
[1mdiff --git a/include/Request.hpp b/include/Request.hpp[m
[1mindex d9ed9a8..3629bba 100644[m
[1m--- a/include/Request.hpp[m
[1m+++ b/include/Request.hpp[m
[36m@@ -18,6 +18,8 @@[m [mclass Request[m
 		Request	&operator=(const Request &ref);[m
 		~Request(void);[m
 		int	parse(str_t input);[m
[32m+[m		[32mint	fd();[m
[32m+[m		[32munsigned int type();[m
 		str_t					_ressource;		//should maybe be called _route...[m
 [m
 		strMap	&headers();[m
[36m@@ -31,7 +33,8 @@[m [mclass Request[m
 		unsigned	int			_type;[m
 		strMap					_headers;[m
 		//URL[m
[31m-		[m
[32m+[m		[32m//char					*_body;[m
[32m+[m		[32mstd::vector<str_t>		_body;[m
 		strMap					_queryParam;[m
 [m
 };[m
[1mdiff --git a/include/Response.hpp b/include/Response.hpp[m
[1mindex 22fa579..bcd7abe 100644[m
[1m--- a/include/Response.hpp[m
[1m+++ b/include/Response.hpp[m
[36m@@ -2,6 +2,7 @@[m
 # define RESPONSE_HPP[m
 [m
 #include "common.hpp"[m
[32m+[m[32m#include "Request.hpp"[m
 [m
 enum [m
 {[m
[36m@@ -34,14 +35,15 @@[m [menum[m
 class Response[m
 {[m
 	public:[m
[31m-		Response(void);[m
[31m-		Response(const Response &ref);[m
[31m-		Response	&operator=(const Response &ref);[m
[32m+[m		[32mResponse(Request req);[m
[32m+[m		[32m//Response(const Response &ref);[m
[32m+[m		[32m//Response	&operator=(const Response &ref);[m
 		~Response(void);[m
 		void 			set_status(unsigned int s);[m
 		unsigned int	status();[m
 		void			send();[m
 	private:[m
[32m+[m		[32mResponse(void);[m
 		unsigned int							_status;[m
 		int										_fd;[m
 		static	std::map<unsigned int, str_t>	_messages;[m
[1mdiff --git a/include/common.hpp b/include/common.hpp[m
[1mindex 3e8b4da..d8a4b38 100644[m
[1m--- a/include/common.hpp[m
[1m+++ b/include/common.hpp[m
[36m@@ -9,6 +9,7 @@[m
 #include <map>[m
 #include <netdb.h>[m
 #include <netinet/in.h>[m
[32m+[m[32m#include <netinet/tcp.h>[m
 #include <sstream>[m
 #include <string>[m
 #include <string.h>[m
[36m@@ -24,15 +25,19 @@[m
 typedef std::string             str_t;[m
 typedef std::pair<str_t, str_t> strPair;[m
 typedef	std::map<str_t, str_t>	strMap;[m
[31m-typedef std::pair<int, time_t>  expiry;[m
[31m-typedef std::list<expiry>		expiryList;[m
[31m-typedef expiryList::iterator    expiryIt;[m
[32m+[m
[32m+[m[32m// typedef std::pair<int, time_t>  expiry;[m
[32m+[m[32m// typedef std::list<expiry>		expiryList;[m
[32m+[m[32m//typedef expiryList::iterator    expiryIt;[m
[32m+[m
[32m+[m
 typedef struct epoll_event      event_t;[m
 typedef struct addrinfo         adrinfo_t;[m
 [m
 time_t	time_in_ms(void);[m
 [m
 void    fatal(str_t str);[m
[32m+[m[32mvoid    assert(bool scal, str_t log);[m
 [m
 #define CRLF            "\r\n"[m
 #define SERVER_VERSION  "HTTP/1.1"[m
[1mdiff --git a/include/find_nocase.hpp b/include/find_nocase.hpp[m
[1mnew file mode 100644[m
[1mindex 0000000..84ab253[m
[1m--- /dev/null[m
[1m+++ b/include/find_nocase.hpp[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m
[32m+[m[32m#include "common.hpp"[m
[32m+[m
[32m+[m[32m// templated version of my_equal so it could work with both char and wchar_t[m
[32m+[m[32mtemplate<typename charT>[m
[32m+[m[32mstruct my_equal {[m
[32m+[m[32m    my_equal( const std::locale& loc ) : loc_(loc) {}[m
[32m+[m[32m    bool operator()(charT ch1, charT ch2) {[m
[32m+[m[32m        return std::toupper(ch1, loc_) == std::toupper(ch2, loc_);[m
[32m+[m[32m    }[m
[32m+[m[32mprivate:[m
[32m+[m[32m    const std::locale& loc_;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// find substring (case insensitive)[m
[32m+[m[32mtemplate<typename T>[m
[32m+[m[32msize_t find_nocase( const T& str1, const T& str2, size_t offset = 0, const std::locale& loc = std::locale() )[m
[32m+[m[32m{[m
[32m+[m[32m    typename T::const_iterator it = std::search( str1.begin() + offset, str1.end(),[m[41m [m
[32m+[m[32m        str2.begin(), str2.end(), my_equal<typename T::value_type>(loc) );[m
[32m+[m[32m    if ( it != str1.end() )[m
[32m+[m[32m        return it - str1.begin();[m
[32m+[m[32m    else[m
[32m+[m[32m        return str1.npos; // not found[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/obj/EvMa.o b/obj/EvMa.o[m
[1mnew file mode 100644[m
[1mindex 0000000..dedc485[m
Binary files /dev/null and b/obj/EvMa.o differ
[1mdiff --git a/obj/Request.o b/obj/Request.o[m
[1mnew file mode 100644[m
[1mindex 0000000..36832a0[m
Binary files /dev/null and b/obj/Request.o differ
[1mdiff --git a/obj/main.o b/obj/main.o[m
[1mnew file mode 100644[m
[1mindex 0000000..25fb645[m
Binary files /dev/null and b/obj/main.o differ
[1mdiff --git a/obj/str_manips.o b/obj/str_manips.o[m
[1mnew file mode 100644[m
[1mindex 0000000..32efb6c[m
Binary files /dev/null and b/obj/str_manips.o differ
[1mdiff --git a/obj/time_in_ms.o b/obj/time_in_ms.o[m
[1mnew file mode 100644[m
[1mindex 0000000..ec24dd2[m
Binary files /dev/null and b/obj/time_in_ms.o differ
[1mdiff --git a/srcs.mk b/srcs.mk[m
[1mindex b1b22c0..fa2e169 100644[m
[1m--- a/srcs.mk[m
[1m+++ b/srcs.mk[m
[36m@@ -1,7 +1,9 @@[m
 SRCS = \[m
[31m-EvMa.cpp\[m
[31m-str_manips.cpp\[m
[31m-main.cpp\[m
[32m+[m[32mClient.cpp\[m
 Request.cpp\[m
[32m+[m[32mstr_manips.cpp\[m
[32m+[m[32mResponse.cpp\[m
[32m+[m[32mEvMa.cpp\[m
 time_in_ms.cpp\[m
[32m+[m[32mmain.cpp\[m
 \[m
[1mdiff --git a/srcs/Client.cpp b/srcs/Client.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..720462b[m
[1m--- /dev/null[m
[1m+++ b/srcs/Client.cpp[m
[36m@@ -0,0 +1,107 @@[m
[32m+[m[32m#include "Client.hpp"[m
[32m+[m[32m#include "find_nocase.hpp"[m
[32m+[m
[32m+[m[32mClient::Client(void)[m
[32m+[m[32m{[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mClient::Client(int fd) : _fd(fd)[m
[32m+[m[32m{[m
[32m+[m	[32mmemset(_buff, 0, MAXREAD+1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Client::Client(const Client &ref)[m
[32m+[m[32m// {[m
[32m+[m[32m// }[m
[32m+[m
[32m+[m[32mClient	&Client::operator=(const Client &ref)[m
[32m+[m[32m{[m
[32m+[m	[32mif (&ref != this)[m
[32m+[m	[32m{[m
[32m+[m		[32m_fd = ref._fd;[m
[32m+[m		[32m_req.clear();[m
[32m+[m		[32m_req = ref._req;[m
[32m+[m		[32m//_input = ref._input;[m
[32m+[m		[32mstrcpy(_buff, ref._buff);[m
[32m+[m		[32m_headers_len = ref._headers_len;[m
[32m+[m		[32m_content_len = ref._content_len;[m
[32m+[m	[32m}[m
[32m+[m	[32mreturn (*this);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mClient::~Client(void)[m
[32m+[m[32m{[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid	Client::add_request()[m
[32m+[m[32m{[m
[32m+[m	[32m_req.push_back(Request(_input.substr(0, _headers_len + _content_len), _fd));[m
[32m+[m	[32m//std::cout << "parsed request :\n" << _input.substr(0, _headers_len + _content_len) << std::endl;[m
[32m+[m	[32m//std::cout << "remaining : " << _input << std::endl;[m
[32m+[m	[32m_input = _input.substr(_headers_len + _content_len);[m
[32m+[m	[32m//std::cout << "remaining : " << _input << std::endl;[m
[32m+[m	[32m_headers_len = 0;[m
[32m+[m	[32m_content_len = 0;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint		Client::fd()[m
[32m+[m[32m{ return (_fd); }[m
[32m+[m
[32m+[m[32mchar	*Client::buff()[m
[32m+[m[32m{ return (_buff); }[m
[32m+[m
[32m+[m[32mtime_t	Client::expire()[m
[32m+[m[32m{ return (_expire); }[m
[32m+[m
[32m+[m[32mint		Client::add_data()[m
[32m+[m[32m{[m
[32m+[m	[32m//std::cout << "\n\n ADD_DATA (fd = " << _fd <<  ")\n";[m
[32m+[m	[32msize_t pos;[m
[32m+[m	[32mmemset(_buff, 0, MAXREAD);[m
[32m+[m	[32mint n;[m
[32m+[m	[32mn  = read(_fd, _buff, MAXREAD-1);[m
[32m+[m	[32mif (n < 0)[m
[32m+[m		[32mreturn (1);[m
[32m+[m[41m	[m
[32m+[m	[32m_input = _input + str_t(_buff);[m
[32m+[m
[32m+[m	[32mstd::cout << _input << std::endl;[m
[32m+[m	[32mif ((pos = find_nocase<std::string>(_input, "CONTENT-LENGTH")) != _input.npos)[m
[32m+[m	[32m{[m
[32m+[m		[32mif (find_nocase<std::string>(_input, "\n", pos) != _input.npos)[m
[32m+[m		[32m{[m
[32m+[m			[32m_content_len = atoi(_input.substr(pos + 17).c_str());[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m	[32mif (((pos = _input.find("\r\n\r\n")) != _input.npos))[m
[32m+[m	[32m{[m
[32m+[m		[32m_headers_len  = pos + 4;[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mif (_input.size() >= _headers_len + _content_len && _input.size())[m
[32m+[m	[32m{[m
[32m+[m[32m        add_request();[m
[32m+[m		[32m_input = _input.substr(_headers_len + _content_len);[m
[32m+[m		[32m//std::cout << "n is :" << n << std::endl;[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
[32m+[m	[32mreturn (0);[m
[32m+[m[41m		[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid	Client::respond()[m
[32m+[m[32m{[m
[32m+[m	[32mstd::cout << "responding\n";[m
[32m+[m	[32mfor (size_t i = 0; i < _req.size(); i++)[m
[32m+[m	[32m{[m
[32m+[m		[32mstd::cout << "response " << i << std::endl;[m
[32m+[m		[32mResponse res(_req[i]);[m
[32m+[m		[32mres.send();[m
[32m+[m	[32m}[m
[32m+[m	[32mclose (_fd);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid	Client::touch()[m
[32m+[m[32m{[m
[32m+[m	[32m_expire = time_in_ms() + 5000;[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/srcs/EvMa.cpp b/srcs/EvMa.cpp[m
[1mindex 3a8b0b0..6826ca2 100644[m
[1m--- a/srcs/EvMa.cpp[m
[1m+++ b/srcs/EvMa.cpp[m
[36m@@ -1,7 +1,8 @@[m
 #include "EvMa.hpp"[m
 #include "Request.hpp"[m
[32m+[m[32m#include "Client.hpp"[m
 [m
[31m-// a terme devra prendre un pointeur sur config (et le garder en tant qu'attribut)[m
[32m+[m[32m// a terme devra prendre une ref sur config (et le garder en tant qu'attribut)[m
 EvMa::EvMa(const char *port, int max_event)[m
 {[m
 	/* should put all of this in init list -- also put missing stuff (nb_events..)*/[m
[36m@@ -11,6 +12,7 @@[m [mEvMa::EvMa(const char *port, int max_event)[m
 	_max_event = max_event;[m
 	_event_nb = 0;[m
 [m
[32m+[m	[32m_clients.reserve(max_event);[m
 	init_socket();			//so maybe private ??[m
 	init_epoll();[m
 }[m
[36m@@ -34,9 +36,9 @@[m [mint	EvMa::unlock_socket(int fd)[m
 	int flags;[m
 	flags = fcntl(fd,  F_GETFL);[m
 	//if (flags == -1)[m
[31m-		//handle_error[m
[32m+[m	[32m//	handle_error[m
 	flags |= O_NONBLOCK;[m
[31m-	if (fcntl(fd, F_SETFL, flags) == -1)[m
[32m+[m	[32mif (fcntl(fd, F_SETFL, O_NONBLOCK) == -1)[m
 		fatal("unlock socket failed");[m
 	return (0);[m
 }[m
[36m@@ -73,23 +75,51 @@[m [mvoid	EvMa::init_epoll()[m
 	_events = static_cast<event_t*>(calloc(_max_event, sizeof(event_t)));[m
 [m
 	_event.data.fd = _socket_fd;[m
[31m-	_event.events = EPOLLIN | EPOLLET;[m
[32m+[m	[32m_event.events = EPOLLIN | EPOLLOUT;[m
 	if (epoll_ctl (_epoll_fd, EPOLL_CTL_ADD, _socket_fd, &_event) == -1) /*intialize interest list*/[m
 		fatal("epoll ctl");[m
 }[m
 [m
[32m+[m[32mvoid enable_keepalive(int sock)[m
[32m+[m[32m{[m
[32m+[m[32m    int yes = 1;[m
[32m+[m[32m    setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(int));[m
[32m+[m
[32m+[m[32m    // int idle = 1;[m
[32m+[m[32m    // setsockopt(sock, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(int));[m
[32m+[m
[32m+[m[32m    // int interval = 1;[m
[32m+[m[32m    // setsockopt(sock, IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof(int));[m
[32m+[m
[32m+[m[32m    // int maxpkt = 10;[m
[32m+[m[32m    // setsockopt(sock, IPPROTO_TCP, TCP_KEEPCNT, &maxpkt, sizeof(int));[m
[32m+[m[32m}[m
[32m+[m
 void	EvMa::add_to_interest(int fd)[m
 {[m
 	unlock_socket(fd);[m
[32m+[m	[32menable_keepalive(fd);[m
 	_event.data.fd = fd;[m
 	_event.events = EPOLLIN | EPOLLET;[m
 	if (epoll_ctl(_epoll_fd, EPOLL_CTL_ADD, fd, &_event) == -1)[m
 		fatal("failed to add incoming connection to interest list.");[m
[31m-	expiry ex = std::make_pair(fd, time_in_ms() + 0);[m
[31m-	_timeouts.push_back(ex);[m
[32m+[m	[32m//expiry ex = std::make_pair(fd, time_in_ms() + 5000);[m
[32m+[m	[32m//_clients.push_back(ex);[m
[32m+[m	[32m_clients.push_back(Client(fd));[m
[32m+[m	[32m(_clients.end()-1)->touch();[m
 	std::cout << "added connection. fd is: " << fd << std::endl;[m
 }[m
 [m
[32m+[m[32mbool    EvMa::is_connected(int fd)[m
[32m+[m[32m{[m
[32m+[m	[32mif (!_clients.size())[m
[32m+[m		[32mreturn (false);[m
[32m+[m	[32mfor (unsigned long i = 0; i < _clients.size(); i++)[m
[32m+[m		[32mif (_clients[i].fd() == fd)[m
[32m+[m			[32mreturn (true);[m
[32m+[m	[32mreturn (false);[m
[32m+[m[32m}[m
[32m+[m
 void	EvMa::incoming_connections()[m
 {[m
 	int fd;[m
[36m@@ -98,7 +128,6 @@[m [mvoid	EvMa::incoming_connections()[m
 [m
 	for (;;)[m
 	{[m
[31m-		[m
 		fd = accept(_socket_fd, &incoming, &incSize); //we accept with socket fd as we listen on this on[m
 		if (fd == -1)[m
 		{[m
[36m@@ -117,62 +146,57 @@[m [mvoid	EvMa::incoming_connections()[m
 [m
 void	EvMa::update_expiry(int fd)[m
 {[m
[31m-	expiryIt it = _timeouts.begin(), ite = _timeouts.end();[m
[31m-	for (; it != ite; it++)[m
[32m+[m
[32m+[m	[32mfor (unsigned long i = 0; i < _clients.size(); i++)[m
 	{[m
[31m-		if (it->first == fd)[m
[32m+[m		[32mif (_clients[i].fd() == fd)[m
 		{[m
[31m-			_timeouts.erase(it);[m
[31m-			_timeouts.push_back(std::make_pair(fd, time_in_ms() + 0));[m
[32m+[m			[32m_clients[i].touch();[m
[32m+[m			[32m_clients.push_back(_clients[i]);[m
[32m+[m			[32m_clients.erase(_clients.begin() + (i - 1));[m
 			return ;[m
 		}[m
 	}[m
 }[m
 [m
[32m+[m[32mClient	&EvMa::find_by_fd(int fd)[m
[32m+[m[32m{[m
[32m+[m	[32mfor (unsigned long i = 0; i < _clients.size(); i++)[m
[32m+[m	[32m{[m
[32m+[m		[32mif (_clients[i].fd() == fd)[m
[32m+[m			[32mreturn (_clients[i]);[m
[32m+[m	[32m}[m
[32m+[m	[32mreturn (_clients[0]);[m
[32m+[m[32m}[m
[32m+[m
 int	EvMa::read_data(int i)[m
 {[m
[31m-	char            recvline[MAXREAD+1];[m
[31m-	str_t			input;[m
[31m-	int 			n;[m
[32m+[m	[32m//int 			n;[m
[32m+[m	[32mClient			&client = find_by_fd(_events[i].data.fd);[m
 [m
 	update_expiry(i);[m
[31m-	memset(recvline, 0, MAXREAD+1);[m
[31m-	while ((n = read(_events[i].data.fd, recvline, MAXREAD-1)) >  0)[m
[31m-    {[m
[31m-        input = input + str_t(recvline);[m
[31m-        if (recvline[n-1] == '\n')[m
[31m-            break ;[m
[31m-		//memset(recvline, 0, MAXREAD+1);[m
[31m-    }[m
[31m-    if (n < 0)[m
[31m-        {fatal("read error");}[m
[32m+[m	[32mif (client.add_data())[m
[32m+[m		[32mclient.respond();[m
[32m+[m
[32m+[m[32m    // if (n <= 0)[m
[32m+[m[32m    // {[m
[32m+[m	[32m// 			//not sure what to do here.. for now my guess is actually respond.[m
[32m+[m	[32m// 	//fatal("read error");[m
[32m+[m	[32m// 	//std::cout << "read error (cannot check errno right now)" << std::endl;[m
[32m+[m	[32m// 	client.respond();[m
[32m+[m	[32m// }[m
[32m+[m
[32m+[m
     //std::cout << input;[m
[31m-	Request			req(input, _events[i].data.fd);[m
[32m+[m	[32m//Request			req(input, _events[i].data.fd);[m
     //req.parse(input);	//now called in constructor[m
 	//req.response();	//might be a bad idea. maybe the response object should be declared here.[m
[31m-						// It mainly depends on what infos we need to respond (spoiler: we probably need a lot.)[m
[31m-[m
[31m-[m
[31m-[m
[32m+[m					[32m// It mainly depends on what infos we need to respond (spoiler: we probably need a lot.)[m
 	//for testing/ cohesion purposes, i copied this ugly thing:[m
 [m
[31m-	std::ifstream       page;[m
[31m-    std::stringstream   buf;[m
[31m-	char				buff[MAXREAD+1];[m
[31m-[m
[31m-	memset(buff, 0, MAXREAD + 1);[m
[31m-	page.open ("./website/home.html", std::ifstream::in);[m
[31m-    buf << page.rdbuf();[m
[31m-    //const std::string& tmp = buf.str();[m
[31m-    //const char* cstr = tmp.c_str();[m
[31m-[m
[31m-	snprintf((char*)buff, sizeof(buff), "HTTP/1.1 200 \r\n\r\n<!OKDOCTYPE html>\n<head>\n</head>\n<body>\n<div>Hello There :)</div>\n<img src=\"image.jpg\"/>\n</body>\n</html>");[m
 [m
[31m-    write(_events[i].data.fd, buff, strlen(buff));[m
 	//send(_events[i].data.fd, buff, strlen(buff), MSG_DONTWAIT); [m
 	//			subject says we can use any of those two ..[m
[31m-[m
[31m-[m
 	//int numbytes;[m
 	// if ((numbytes = recv(_socket_fd, buff, MAXREAD, MSG_DONTWAIT)) == 0)[m
 	// {[m
[36m@@ -180,31 +204,41 @@[m [mint	EvMa::read_data(int i)[m
 	// 	close(_events[i].data.fd);[m
 	// }[m
 	//fsync(_events[i].data.fd);						//this is a "flush". since we dont always close the ssocket right now, the data are not actually sent.[m
[31m-													// this clears the buffer and force the data to be sent.[m
[31m-[m
[32m+[m												[32m// this clears the buffer and force the data to be sent.[m
 	//if (req.headers().count("connection") && req.headers()["connection"] == "close")[m
[31m-		close(_events[i].data.fd);[m
[31m-	return (0); [m
[32m+[m	[32m//	break;[m
[32m+[m	[32m//close(_events[i].data.fd);[m
[32m+[m	[32mreturn (0);[m
[32m+[m[32m}[m
 [m
[32m+[m[32mint	EvMa::write_data(int i)[m
[32m+[m[32m{[m
[32m+[m	[32mClient			&client = _clients[_events[i].data.fd];[m
[32m+[m
[32m+[m	[32mclient.respond();[m
[32m+[m	[32mreturn (0);[m
 }[m
 [m
 int	EvMa::timeout()[m
 {[m
[31m-	if (!_timeouts.size())				//we do not have any open connections and don't need any timeout[m
[32m+[m	[32mif (!_clients.size())				//we do not have any open connections and don't need any timeout[m
 		return (-1);[m
[31m-	int to = _timeouts.begin()->second  -  time_in_ms();[m
[32m+[m	[32mint to = _clients.begin()->expire() - time_in_ms();[m
 	if (to > 0)[m
 		return (to);[m
 	return (-1);[m
 }[m
 [m
[31m-expiryIt	EvMa::disconnect_socket(expiryIt expired)[m
[32m+[m[32mclient_v::iterator	EvMa::disconnect_socket(client_v::iterator expired)[m
 {[m
[31m-	std::cout << "closed connection to socket nb " << expired->first << std::endl;[m
[31m-	close(expired->second);[m
[31m-	expiryIt tmp = expired;[m
[32m+[m	[32mif (expired->fd() == 0)[m
[32m+[m		[32mreturn (expired);[m
[32m+[m	[32mstd::cout << "closed connection to socket nb " << expired->fd() << std::endl;[m
[32m+[m	[32mclose(expired->fd());[m
[32m+[m	[32m//epoll_ctl(_epoll_fd, EPOLL_CTL_DEL, expired->first, NULL);[m
[32m+[m	[32mclient_v::iterator tmp = expired;[m
 	expired++;[m
[31m-	_timeouts.erase(tmp);[m
[32m+[m	[32m_clients.erase(tmp);[m
 	return (expired);[m
 }[m
 [m
[36m@@ -213,18 +247,34 @@[m [mvoid	EvMa::loop()[m
 	for (;;)[m
 	{[m
 		_event_nb = epoll_wait(_epoll_fd, _events, _max_event, timeout()); //-1 for timeout means it will block unedfinitely. check if that's the behaviour we want.[m
[32m+[m		[32mstd::cout << "event_nb = "<<  _event_nb << "\n";[m
 		for (int i = 0; i < _event_nb; i++)[m
 		{[m
[32m+[m			[32mint fd = _events[i].data.fd;[m
[32m+[m			[32muint32_t ev = _events->events;[m
 			//HANDLE ERROR WITH & BITWISE OP (why tho). if error, continue[m
[31m-			if (_events[i].data.fd == _socket_fd)[m
[32m+[m			[32mif (fd == _socket_fd)[m
 				incoming_connections();[m
[31m-			else[m
[32m+[m			[32melse if (ev & (EPOLLRDHUP | EPOLLHUP | EPOLLERR))[m
[32m+[m			[32m{[m
[32m+[m				[32massert(is_connected(fd), "disconnect/ could not find fd");[m
[32m+[m				[32mdisconnect_socket(_clients.begin() + (i - 1));[m
[32m+[m			[32m}[m
[32m+[m			[32melse if (ev & EPOLLIN)[m
[32m+[m			[32m{[m
[32m+[m				[32massert(is_connected(fd), "read/ could not find fd");[m
 				read_data(i);[m
[32m+[m			[32m}[m
[32m+[m			[32melse if (ev & EPOLLOUT)[m
[32m+[m			[32m{[m
[32m+[m				[32massert(is_connected(fd), "write/ could not find fd");[m
[32m+[m				[32mwrite_data(i);[m
[32m+[m			[32m}[m
 		}[m
[31m-		if (!_timeouts.size())[m
[32m+[m		[32mif (!_clients.size())[m
 			continue;[m
[31m-		_event_nb = 0;[m
[31m-		for (expiryIt ex = _timeouts.begin(); ex != _timeouts.end() && ex->second < time_in_ms(); ex++)[m
[32m+[m		[32m//_event_nb = 0;[m
[32m+[m		[32mfor (client_v::iterator ex = _clients.begin(); ex != _clients.end() && ex->expire() < time_in_ms(); ex++)[m
     		ex = disconnect_socket(ex);[m
 		[m
 	}[m
[1mdiff --git a/srcs/Request.cpp b/srcs/Request.cpp[m
[1mindex 36ecee1..e19244d 100644[m
[1m--- a/srcs/Request.cpp[m
[1m+++ b/srcs/Request.cpp[m
[36m@@ -1,5 +1,6 @@[m
[31m-#include "../include/Request.hpp"[m
[31m-#include "../include/str_manips.hpp"[m
[32m+[m[32m#include "Request.hpp"[m
[32m+[m[32m#include "str_manips.hpp"[m
[32m+[m[32m#include "find_nocase.hpp"[m
 [m
 Request::Request(str_t input, int fd) : _fd((fd))[m
 {[m
[36m@@ -89,26 +90,66 @@[m [mint	Request::parse_TopLine(str_t line)[m
 	return (0);[m
 }[m
 [m
[32m+[m[32mint	Request::fd()[m
[32m+[m[32m{ return (_fd); }[m
 [m
[32m+[m[32munsigned int Request::type()[m
[32m+[m[32m{ return (_type); }[m
 [m
 int	Request::parse(str_t input)[m
 {[m
[31m-	int ret;[m
[31m-	str_t line;[m
[32m+[m	[32mint					ret;[m
[32m+[m	[32mstr_t				line;[m
[32m+[m	[32mstd::vector<str_t>	lines;[m
[32m+[m	[32mint					sum = 0;[m
[32m+[m	[32mint					check = 0;[m
[32m+[m	[32mint					cl;[m
[32m+[m	[32mint					hl;[m
 [m
[31m-	if ((ret = parse_TopLine(newLine(input))))[m
[31m-		return (ret);[m
[31m-	[m
 	while ((line = newLine(input)).size())[m
 	{[m
[32m+[m		[32mlines.push_back(line);[m
[32m+[m		[32msum += line.size();[m
[32m+[m	[32m}[m
[32m+[m	[32mfor (std::vector<str_t>::iterator it = lines.begin(); it != lines.end(); it++)[m
[32m+[m	[32m{[m
[32m+[m		[32mif (find_nocase<str_t>(*it, "content-length") != it->npos)[m
[32m+[m		[32m{[m
[32m+[m			[32mint i;[m
[32m+[m			[32mstr_t str = it->substr(16);[m
[32m+[m			[32mstd::istringstream(str) >> i;[m
[32m+[m			[32mcl = i;[m
[32m+[m			[32mhl = sum - cl;[m
[32m+[m			[32mbreak;[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mif ((ret = parse_TopLine(lines[0])))[m
[32m+[m	[41m [m	[32mreturn (ret);[m
[32m+[m[41m	[m
[32m+[m	[32mstd::vector<str_t>::iterator it = lines.begin();[m
[32m+[m	[32mfor (; it != lines.end(); it++)[m
[32m+[m	[32m{[m
[32m+[m		[32mif (check >= hl)[m
[32m+[m			[32mbreak;[m
 		strPair p;[m
[31m-		size_t	limit = line.find(':');[m
[31m-		p.first = str_toUpper(line.substr(0, limit++));[m
[31m-		while (isspace(line[limit++]));[m
[32m+[m		[32msize_t	limit = it->find(':');[m
[32m+[m		[32mp.first = str_toUpper(it->substr(0, limit++));[m
[32m+[m		[32mwhile (isspace((*it)[limit++]));[m
 		limit--;[m
[31m-		p.second = line.substr(limit, line.npos);[m
[32m+[m		[32mp.second = it->substr(limit, line.npos);[m
 		_headers.insert(p);[m
[32m+[m		[32mcheck += it->size();[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32m_body = std::vector<str_t>(it, lines.end());[m
[32m+[m
[32m+[m	[32mstd::cout << "----------\n";[m
[32m+[m	[32mfor (std::vector<str_t>::iterator itb = _body.begin(); itb != _body.end(); itb++)[m
[32m+[m	[32m{[m
[32m+[m		[32mstd::cout << *itb << std::endl;[m
 	}[m
[32m+[m	[32mstd::cout << "----------\n";[m
 	return (EXIT_SUCCESS);[m
 }[m
 [m
[1mdiff --git a/srcs/Response.cpp b/srcs/Response.cpp[m
[1mindex 988568e..aa4cf69 100644[m
[1m--- a/srcs/Response.cpp[m
[1m+++ b/srcs/Response.cpp[m
[36m@@ -1,22 +1,28 @@[m
 #include "../include/Response.hpp"[m
 [m
[31m-Response::Response(void)[m
[32m+[m[32mResponse::Response(void)[m[41m [m
 {[m
 }[m
 [m
[31m-Response::Response(const Response &ref)[m
[31m-{[m
[31m-}[m
[32m+[m[32m// Response::Response(const Response &ref)[m
[32m+[m[32m// {[m
[32m+[m[32m// }[m
 [m
[31m-Response	&Response::operator=(const Response &ref)[m
[32m+[m[32m// Response	&Response::operator=(const Response &ref)[m
[32m+[m[32m// {[m
[32m+[m[32m// 	return (*this);[m
[32m+[m[32m// }[m
[32m+[m
[32m+[m[32mResponse::~Response(void)[m
 {[m
[31m-	return (*this);[m
 }[m
 [m
[31m-Response::~Response(void)[m
[32m+[m[32mResponse::Response(Request req) : _fd(req.fd())[m
 {[m
[32m+[m[41m	 [m
 }[m
 [m
[32m+[m
 void			Response::set_status(unsigned int s)[m
 {[m
 	_status = s;[m
[36m@@ -29,5 +35,14 @@[m [munsigned int	Response::status()[m
 [m
 void			Response::send()[m
 {[m
[31m-[m
[32m+[m	[32m(void)_fd;[m
[32m+[m	[32m(void)_body;[m
[32m+[m	[32mstd::ifstream       page;[m
[32m+[m[32m    std::stringstream   buf;[m
[32m+[m	[32mchar				buff[MAXREAD+1];[m
[32m+[m	[32mmemset(buff, 0, MAXREAD + 1);[m
[32m+[m	[32mpage.open ("./website/home.html", std::ifstream::in);[m
[32m+[m[32m    buf << page.rdbuf();[m
[32m+[m	[32msnprintf((char*)buff, sizeof(buff), "HTTP/1.1 200 \r\n\r\n<!OKDOCTYPE html>\n<head>\n</head>\n<body>\n<div>Hello There :)</div>\n<img src=\"image.jpg\"/>\n</body>\n</html>");[m
[32m+[m	[32mwrite(_fd, (char*)buff, sizeof(buff));[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/srcs/main.cpp b/srcs/main.cpp[m
[1mindex f66ec5a..4d0f57f 100644[m
[1m--- a/srcs/main.cpp[m
[1m+++ b/srcs/main.cpp[m
[36m@@ -2,7 +2,6 @@[m
 #include "../include/Request.hpp"[m
 #include "EvMa.hpp"[m
 [m
[31m-[m
 #define DEFAULT_PORT	8002[m
 #define MAX_EVENTS		5[m
 [m
[36m@@ -12,6 +11,12 @@[m [mvoid    fatal(str_t str)[m
     exit(EXIT_FAILURE);[m
 }[m
 [m
[32m+[m[32mvoid    assert(bool scal, str_t log)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!scal)[m
[32m+[m[32m        fatal(log);[m
[32m+[m[32m}[m
[32m+[m
 [m
 int main(int argc, char **argv)[m
 {[m
[1mdiff --git a/webserv b/webserv[m
[1mnew file mode 100755[m
[1mindex 0000000..fd58ca9[m
Binary files /dev/null and b/webserv differ
